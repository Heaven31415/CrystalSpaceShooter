require "crsfml/graphics"
require "zlib"

class PackedResources(T)
  getter resources

  @resources = Array({name: String, bytes: Bytes}).new

  def initialize(filename : String)
    info = File.info? filename
    unless info
      raise "Unable to find anything at: '#{filename}'"
    end

    unless info.file?
      raise "Unable to build PackedResources(#{T}) using: '#{info.type}'"
    else
      load_from_file(filename)
    end
  end

  private def initialize(@resources)
  end

  def self.from_directory(dirname : String, erase_extensions : Bool) : self
    resources = files_to_bytes(dirname, erase_extensions)
    resources.sort! { |a, b| a[:name] <=> b[:name] }
    self.new(resources)
  end

  def load_from_file(filename : String)
    file = File.new(filename)

    Zlib::Reader.open(file) do |io|
      unless read_header(io)
        raise "Invalid header at '#{filename}'"
      end

      unless read_typename(io)
        raise "Invalid typename at '#{filename}'"
      end

      resource_count = read_resource_count(io)
      resource_count.times do |i|
        @resources << read_resource(io)
      end
    end
  end

  private def write_header(io : IO)
    header = "PACKED"
    io.write(header.to_slice)
  end

  private def read_header(io : IO) : Bool
    io.read_string(6) == "PACKED"
  end

  private def write_typename(io : IO)
    slice = T.name.to_slice
    size = slice.size
    io.write_bytes(size, IO::ByteFormat::LittleEndian)
    io.write(slice)
  end

  private def read_typename(io : IO) : Bool
    size = io.read_bytes(Int32, IO::ByteFormat::LittleEndian)
    typename = io.read_string(size)
    typename == T.name
  end

  private def write_resource_count(io : IO)
    io.write_bytes(@resources.size, IO::ByteFormat::LittleEndian)
  end

  private def read_resource_count(io : IO) : Int32
    io.read_bytes(Int32, IO::ByteFormat::LittleEndian)
  end

  private def write_resource(io : IO, resource : {name: String, bytes: Bytes})
    io.write_bytes(resource[:name].to_slice.size, IO::ByteFormat::LittleEndian)
    io.write(resource[:name].to_slice)

    io.write_bytes(resource[:bytes].size, IO::ByteFormat::LittleEndian)
    io.write(resource[:bytes])
  end

  private def read_resource(io : IO) : {name: String, bytes: Bytes}
    name_size = io.read_bytes(Int32, IO::ByteFormat::LittleEndian)
    name = io.read_string(name_size)

    bytes_size = io.read_bytes(Int32, IO::ByteFormat::LittleEndian)
    bytes = Bytes.new(bytes_size)
    io.read_fully(bytes)

    {name: name, bytes: bytes}
  end

  def save(path : String)
    Zlib::Writer.open(path, Zlib::BEST_COMPRESSION) do |io|
      write_header(io)
      write_typename(io)
      write_resource_count(io)
      @resources.each do |r|
        write_resource(io, r)
      end
    end
  end

  def save_debug(path : String)
    File.open(path, "w") do |io|
      write_header(io)
      write_typename(io)
      write_resource_count(io)
      @resources.each do |r|
        write_resource(io, r)
      end
    end 
  end

  def build_enum(path : String, name : String)
    max_name_length = @resources.max_of do |r|
      r[:name].size
    end

    File.open(path, "w") do |f|
      f << "#" * 45 << '\n'
      f << "# Autogenerated at " << Time.now << '\n'
      f << "#" * 45 << '\n'
      f << '\n'
      f << "enum " << name << '\n'

      @resources.each_with_index do |r, i|
        whitespace = max_name_length + 1 - r[:name].size
        f << "  " << r[:name] << " " * whitespace << " = " << i << '\n'
      end
      f << "end"
    end

    puts "Successfully built enum '#{name}' with #{@resources.size} members at: '#{path}'"
  end
end

private def convert_filename(filename : String, erase_extensions : Bool) : String
  if erase_extensions
    ext = File.extname(filename)
    filename.underscore.chomp(ext).upcase.gsub(' ', '_')
  else
    filename.underscore.upcase.gsub(/[ \.]/, '_')
  end
end

private def file_to_bytes(path : String) : Bytes
  unless File.exists? path
    raise "Unable to find file at: '#{path}'"
  end

  f = File.open(path)
  slice = Bytes.new(f.size)
  f.read(slice)
  f.close

  slice
end

private def files_to_bytes(dir_path : String, erase_extensions : Bool) : Array({name: String, bytes: Bytes})
  unless Dir.exists? dir_path
    raise "Unable to find directory at: '#{dir_path}'"
  end

  named_slices = Array({name: String, bytes: Bytes}).new

  Dir.each_child(dir_path) do |f|
    path = File.join(dir_path, f)
    if File.info(path).file?
      name = convert_filename(f, erase_extensions)
      named_slices << {name: name, bytes: file_to_bytes(path)}
    end
  end

  named_slices
end