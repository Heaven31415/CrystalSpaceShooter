require "crsfml/graphics"
require "zlib"

module Tools
  extend self 

  def file_to_bytes(path : String) : Bytes
    unless File.exists? path
      raise "Unable to find file at: `#{path}`"
    end
  
    f = File.open(path)
    slice = Bytes.new(f.size)
    f.read(slice)
    f.close
  
    slice
  end
  
  def files_to_bytes(dir_path : String) : Array({name: String, bytes: Bytes})
    unless Dir.exists? dir_path
      raise "Unable to find directory at: `#{dir_path}`"
    end
  
    named_slices = Array({name: String, bytes: Bytes}).new
  
    Dir.each_child(dir_path) do |f|
      path = File.join(dir_path, f)
      if File.info(path).file?
        named_slices << {name: f.chomp(File.extname(f)), bytes: file_to_bytes(path)}
      end
    end
  
    named_slices
  end
end

class PackedResources(T)
  def initialize(path : String)
    info = File.info? path
    unless info
      raise "Unable to find anything at: `#{path}`"
    end

    case info
    when .directory?
      @resources = PackedResources(T).create(path)
    when .file?
      @resources = PackedResources(T).load(path)
    else
      raise "Unable to build PackedResources(#{T}) with: `#{info.type}`"
    end
  end

  def unpack(key : K.class) : Hash(K, T) forall K
    resources = Hash(K, T).new
    @resources.each do |r|
      key = K.parse? r[:name]
      if key
        resources[key] = T.from_memory(r[:bytes])
      end
    end
    resources
  end

  def self.create(path : String) : Array({name: String, bytes: Bytes})
    resources = Tools.files_to_bytes(path)
    resources.sort! { |a, b| a[:name] <=> b[:name] }
    resources
  end

  def self.load(path : String) : Array({name: String, bytes: Bytes})
    resources = Array({name: String, bytes: Bytes}).new
    file = File.new(path)

    Zlib::Reader.open(file) do |io|
      unless self.read_header(io)
        raise "Invalid header at `#{path}`"
      end

      unless self.read_typename(io)
        raise "Invalid typename at `#{path}`"
      end

      resource_count = self.read_resource_count(io)
      resource_count.times do |i|
        resources << self.read_resource(io)
      end
    end
    
    resources
  end

  private def write_header(io : IO)
    header = "PACKED"
    io.write(header.to_slice)
  end

  private def self.read_header(io : IO) : Bool
    io.read_string(6) == "PACKED"
  end

  private def write_typename(io : IO)
    slice = T.name.to_slice
    size = slice.size
    io.write_bytes(size, IO::ByteFormat::LittleEndian)
    io.write(slice)
  end

  private def self.read_typename(io : IO) : Bool
    size = io.read_bytes(Int32, IO::ByteFormat::LittleEndian)
    typename = io.read_string(size)
    typename == T.name
  end

  private def write_resource_count(io : IO)
    io.write_bytes(@resources.size, IO::ByteFormat::LittleEndian)
  end

  private def self.read_resource_count(io : IO) : Int32
    io.read_bytes(Int32, IO::ByteFormat::LittleEndian)
  end

  private def write_resource(io : IO, resource : {name: String, bytes: Bytes})
    io.write_bytes(resource[:name].to_slice.size, IO::ByteFormat::LittleEndian)
    io.write(resource[:name].to_slice)

    io.write_bytes(resource[:bytes].size, IO::ByteFormat::LittleEndian)
    io.write(resource[:bytes])
  end

  private def self.read_resource(io : IO) : {name: String, bytes: Bytes}
    name_size = io.read_bytes(Int32, IO::ByteFormat::LittleEndian)
    name = io.read_string(name_size)

    bytes_size = io.read_bytes(Int32, IO::ByteFormat::LittleEndian)
    bytes = Bytes.new(bytes_size)
    io.read_fully(bytes)

    {name: name, bytes: bytes}
  end

  def save(path : String)
    Zlib::Writer.open(path, Zlib::BEST_COMPRESSION) do |io|
      write_header(io)
      write_typename(io)
      write_resource_count(io)
      @resources.each do |r|
        write_resource(io, r)
      end
    end
  end

  def save_debug(path : String)
    File.open(path, "w") do |io|
      write_header(io)
      write_typename(io)
      write_resource_count(io)
      @resources.each do |r|
        write_resource(io, r)
      end
    end 
  end

  def build_enum(path : String, name : String)
    max_name_length = @resources.max_of do |r|
      r[:name].size
    end

    File.open(path, "w") do |f|
      f << "#" * 45 << '\n'
      f << "# Autogenerated at " << Time.now << '\n'
      f << "#" * 45 << '\n'
      f << '\n'
      f << "enum " << name.capitalize << '\n'

      @resources.each_with_index do |r, i|
        whitespace = max_name_length + 1 - r[:name].size
        f << "  " << r[:name].camelcase << " " * whitespace << " = " << i << '\n'
      end
      f << "end"
    end
  end
end